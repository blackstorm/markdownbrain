<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mdbrain App Tests</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        .test-suite {
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
        }
        .test-case {
            margin: 5px 0;
            padding: 5px;
        }
        .pass {
            color: green;
        }
        .fail {
            color: red;
            font-weight: bold;
        }
        .summary {
            margin-top: 20px;
            padding: 10px;
            background: #f0f0f0;
            font-weight: bold;
        }
        #notification-container {
            position: fixed;
            top: 0;
            right: 0;
        }
    </style>
</head>
<body>
    <h1>Mdbrain App Test Suite</h1>
    <div id="test-results"></div>
    <div id="notification-container"></div>

    <script src="/js/helpers.js"></script>
    <script>
        // Simple test framework
        let testResults = [];
        let currentSuite = '';

        function describe(suiteName, fn) {
            currentSuite = suiteName;
            console.log(`\n=== ${suiteName} ===`);
            fn();
        }

        function test(testName, fn) {
            try {
                fn();
                testResults.push({ suite: currentSuite, name: testName, pass: true });
                console.log(`✓ ${testName}`);
            } catch (error) {
                testResults.push({ suite: currentSuite, name: testName, pass: false, error: error.message });
                console.error(`✗ ${testName}:`, error.message);
            }
        }

        function expect(actual) {
            return {
                toBe(expected) {
                    if (actual !== expected) {
                        throw new Error(`Expected ${expected}, got ${actual}`);
                    }
                },
                toEqual(expected) {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                    }
                },
                toBeTruthy() {
                    if (!actual) {
                        throw new Error(`Expected truthy value, got ${actual}`);
                    }
                },
                toBeFalsy() {
                    if (actual) {
                        throw new Error(`Expected falsy value, got ${actual}`);
                    }
                },
                toContain(expected) {
                    if (!actual.includes(expected)) {
                        throw new Error(`Expected to contain ${expected}`);
                    }
                },
                toBeInstanceOf(constructor) {
                    if (!(actual instanceof constructor)) {
                        throw new Error(`Expected instance of ${constructor.name}`);
                    }
                },
                toBeNull() {
                    if (actual !== null) {
                        throw new Error(`Expected null, got ${actual}`);
                    }
                },
                toHaveProperty(property) {
                    if (!(property in actual)) {
                        throw new Error(`Expected to have property ${property}`);
                    }
                }
            };
        }

        // Run tests
        describe('copyToClipboard', () => {
            test('should be a function', () => {
                expect(typeof window.copyToClipboard).toBe('function');
            });

            test('should exist in global scope', () => {
                expect(window.copyToClipboard).toBeTruthy();
            });

            test('should handle navigator.clipboard existence', () => {
                const hasClipboard = 'clipboard' in navigator;
                expect(typeof hasClipboard).toBe('boolean');
            });
        });

        describe('showNotification', () => {
            test('should be a function', () => {
                expect(typeof window.showNotification).toBe('function');
            });

            test('should create notification element', () => {
                const container = document.getElementById('notification-container');
                expect(container).toBeTruthy();

                window.showNotification('Test message', 'info');

                // Check if notification was added
                const notifications = container.children;
                expect(notifications.length).toBe(1);
            });

            test('should support different notification types', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = ''; // Clear previous

                const types = ['success', 'error', 'info', 'warning'];
                types.forEach(type => {
                    window.showNotification(`Test ${type}`, type);
                });

                expect(container.children.length).toBe(types.length);
            });

            test('should default to info type', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = '';

                window.showNotification('Default type');

                const notification = container.firstElementChild;
                expect(notification.className).toContain('bg-blue-500');
            });

            test('should set message as text content', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = '';

                const message = 'This is a test notification';
                window.showNotification(message);

                const notification = container.firstElementChild;
                expect(notification.textContent).toBe(message);
            });

            test('should apply correct CSS classes', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = '';

                window.showNotification('Success message', 'success');

                const notification = container.firstElementChild;
                expect(notification.className).toContain('fixed');
                expect(notification.className).toContain('bg-green-500');
                expect(notification.className).toContain('rounded-lg');
            });

            test('should handle missing container gracefully', () => {
                const originalContainer = document.getElementById('notification-container');
                originalContainer.id = 'temp-hidden';

                // Should not throw error
                window.showNotification('Test');

                originalContainer.id = 'notification-container';
            });
        });

        describe('formatDate', () => {
            test('should be a function', () => {
                expect(typeof window.formatDate).toBe('function');
            });

            test('should format valid date string', () => {
                const dateStr = '2025-12-21T10:00:00Z';
                const result = window.formatDate(dateStr);

                expect(typeof result).toBe('string');
                expect(result.length).toBe(19); // Format: YYYY/MM/DD HH:MM
            });

            test('should handle empty string', () => {
                const result = window.formatDate('');
                expect(result).toBe('');
            });

            test('should handle null', () => {
                const result = window.formatDate(null);
                expect(result).toBe('');
            });

            test('should handle undefined', () => {
                const result = window.formatDate(undefined);
                expect(result).toBe('');
            });

            test('should format ISO date strings', () => {
                const dateStr = '2025-12-21T15:30:00Z';
                const result = window.formatDate(dateStr);

                expect(result).toBeTruthy();
                expect(result).toContain('2025');
            });

            test('should use Chinese locale', () => {
                const dateStr = '2025-12-21T10:00:00Z';
                const result = window.formatDate(dateStr);

                // Chinese date format uses / as separator
                expect(result).toContain('/');
            });
        });

        describe('Global functions', () => {
            test('copyToClipboard should be accessible globally', () => {
                expect(window.copyToClipboard).toBeTruthy();
                expect(typeof window.copyToClipboard).toBe('function');
            });

            test('showNotification should be accessible globally', () => {
                expect(window.showNotification).toBeTruthy();
                expect(typeof window.showNotification).toBe('function');
            });

            test('formatDate should be accessible globally', () => {
                expect(window.formatDate).toBeTruthy();
                expect(typeof window.formatDate).toBe('function');
            });

            test('all functions should be in window scope', () => {
                const functions = ['copyToClipboard', 'showNotification', 'formatDate'];
                functions.forEach(fn => {
                    expect(fn in window).toBeTruthy();
                });
            });
        });

        describe('Notification auto-removal', () => {
            test('notification should be removed after timeout', (done) => {
                const container = document.getElementById('notification-container');
                container.innerHTML = '';

                window.showNotification('Temp notification');

                expect(container.children.length).toBe(1);

                // Check after 3.5 seconds (timeout is 3 seconds)
                setTimeout(() => {
                    expect(container.children.length).toBe(0);
                    testResults.push({
                        suite: currentSuite,
                        name: 'notification should be removed after timeout',
                        pass: true
                    });
                    renderResults();
                }, 3500);
            });
        });

        describe('DOM elements', () => {
            test('notification-container should exist', () => {
                const container = document.getElementById('notification-container');
                expect(container).toBeTruthy();
            });

            test('notification-container should be empty initially', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = ''; // Clean slate
                expect(container.children.length).toBe(0);
            });
        });

        describe('Error handling', () => {
            test('showNotification handles unknown type gracefully', () => {
                const container = document.getElementById('notification-container');
                container.innerHTML = '';

                window.showNotification('Test', 'unknown-type');

                const notification = container.firstElementChild;
                // Should default to info (blue)
                expect(notification.className).toContain('bg-blue-500');
            });

            test('formatDate handles invalid date string', () => {
                const result = window.formatDate('invalid-date');
                // Should return a string (even if "Invalid Date")
                expect(typeof result).toBe('string');
            });
        });

        // Render results
        function renderResults() {
            const resultsDiv = document.getElementById('test-results');

            let html = '';
            let suites = {};

            // Group by suite
            testResults.forEach(result => {
                if (!suites[result.suite]) {
                    suites[result.suite] = [];
                }
                suites[result.suite].push(result);
            });

            // Render each suite
            for (const [suiteName, tests] of Object.entries(suites)) {
                html += `<div class="test-suite">`;
                html += `<h3>${suiteName}</h3>`;
                tests.forEach(test => {
                    const status = test.pass ? '✓' : '✗';
                    const className = test.pass ? 'pass' : 'fail';
                    html += `<div class="test-case ${className}">`;
                    html += `${status} ${test.name}`;
                    if (!test.pass && test.error) {
                        html += `<br><small>Error: ${test.error}</small>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            }

            // Summary
            const total = testResults.length;
            const passed = testResults.filter(r => r.pass).length;
            const failed = total - passed;

            html += `<div class="summary">`;
            html += `Total: ${total} | Passed: ${passed} | Failed: ${failed}`;
            if (failed === 0) {
                html += ` | ✓ All tests passed!`;
            }
            html += `</div>`;

            resultsDiv.innerHTML = html;
        }

        // Initial render (async test will re-render)
        setTimeout(() => renderResults(), 100);
    </script>
</body>
</html>
